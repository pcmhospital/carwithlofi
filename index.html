<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lo-Fi Drive</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: #000;
        overflow: hidden;
        user-select: none;
      }

      #gameContainer {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      /* UI Elements */
      .ui-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 100;
      }

      .mood-selector {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        padding: 15px;
        border-radius: 20px;
        pointer-events: all;
      }

      .mood-btn {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        font-size: 18px;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
      }

      .mood-btn:hover,
      .mood-btn.active {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .mode-toggle {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        padding: 10px;
        border-radius: 25px;
        pointer-events: all;
      }

      .mode-btn {
        padding: 12px 20px;
        border: none;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
      }

      .mode-btn:hover,
      .mode-btn.active {
        background: rgba(255, 255, 255, 0.3);
      }

      .controls-info {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        padding: 15px;
        border-radius: 15px;
        color: white;
        font-size: 12px;
        pointer-events: all;
        max-width: 200px;
      }

      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        z-index: 1000;
        transition: opacity 1s ease;
      }

      .loading-text {
        font-size: 24px;
        margin-bottom: 20px;
      }

      .loading-bar {
        width: 300px;
        height: 4px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
        overflow: hidden;
      }

      .loading-progress {
        height: 100%;
        background: white;
        width: 0%;
        transition: width 0.3s ease;
      }

      @media (max-width: 768px) {
        .mood-selector {
          top: 10px;
          right: 10px;
          padding: 10px;
        }

        .mood-btn {
          width: 40px;
          height: 40px;
          font-size: 16px;
        }

        .controls-info {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer"></div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
      <div class="mood-selector">
        <button class="mood-btn" data-mood="morning">üåÖ</button>
        <button class="mood-btn active" data-mood="sunset">üåá</button>
        <button class="mood-btn" data-mood="night">üåô</button>
        <button class="mood-btn" data-mood="rain">üåßÔ∏è</button>
      </div>

      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="driving">üöó Drive</button>
        <button class="mode-btn" data-mode="standing">‚è∏Ô∏è Chill</button>
      </div>

      <div class="controls-info">
        <strong>Controls:</strong><br />
        WASD / Arrow Keys - Drive<br />
        Space / F - Toggle Auto/Manual<br />
        M - Toggle Music<br />
        Click moods to change vibe
      </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div class="loading-text">Loading your chill drive...</div>
      <div class="loading-bar">
        <div class="loading-progress" id="loadingProgress"></div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script>
      class LoFiDriveGame {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.car = null;
          this.terrain = [];
          this.currentMood = "sunset";
          this.isDriving = true;
          this.isAutoMode = true;
          this.audioContext = null;
          this.audioManager = null;

          // Input handling
          this.keys = {};
          this.mouseX = 0;
          this.mouseY = 0;

          // Initialize arrays for terrain management
          this.terrainChunks = [];
          this.groundChunks = [];
          this.trees = [];
          this.chunkSize = 100;
          this.visibleChunks = 5;

          // Performance tracking
          this.loadingProgress = 0;
          this.assetsLoaded = 0;
          this.totalAssets = 8;

          this.init();
        }

        async init() {
          this.detectUserPreferences();
          this.setupThreeJS();
          this.setupAudio();
          this.setupEventListeners();
          await this.loadAssets();
          this.createScene();
          this.animate();
          this.hideLoadingScreen();
        }

        detectUserPreferences() {
          const now = new Date();
          const hour = now.getHours();

          // Time-based mood detection
          if (hour >= 6 && hour < 12) this.currentMood = "morning";
          else if (hour >= 12 && hour < 18) this.currentMood = "sunset";
          else if (hour >= 18 && hour < 22) this.currentMood = "sunset";
          else this.currentMood = "night";

          // Dark mode detection
          const prefersDark = window.matchMedia(
            "(prefers-color-scheme: dark)"
          ).matches;
          if (prefersDark && (hour < 6 || hour > 20)) {
            this.currentMood = "night";
          }

          // Update UI
          document.querySelectorAll(".mood-btn").forEach((btn) => {
            btn.classList.remove("active");
            if (btn.dataset.mood === this.currentMood) {
              btn.classList.add("active");
            }
          });
        }

        setupThreeJS() {
          // Scene setup
          this.scene = new THREE.Scene();

          // Camera setup
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );

          // Renderer setup
          const isMobile = /iPhone|iPad|iPod|Android/i.test(
            navigator.userAgent
          );
          this.renderer = new THREE.WebGLRenderer({
            antialias: !isMobile,
            powerPreference: "high-performance",
          });

          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

          document
            .getElementById("gameContainer")
            .appendChild(this.renderer.domElement);

          // Handle resize
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });
        }

        setupAudio() {
          try {
            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            this.audioManager = new AudioManager(this.audioContext);
          } catch (e) {
            console.log("Web Audio not supported");
          }
        }

        async loadAssets() {
          // UPDATE THIS SECTION TO LOAD YOUR ASSETS
          // Replace these placeholder paths with your actual asset paths

          const assetPaths = {
            // 3D Models - PUT YOUR .GLB FILES HERE
            car: "./assets/models/car.glb", // Your car model
            trees: "./assets/models/trees.glb", // Tree models
            rocks: "./assets/models/rocks.glb", // Rock/prop models

            // Textures - PUT YOUR TEXTURE FILES HERE
            roadTexture: "./assets/textures/road.jpg", // Road texture
            grassTexture: "./assets/textures/grass.jpg", // Grass texture
            skyTexture: "./assets/textures/sky.jpg", // Sky texture or HDRI

            // Audio - PUT YOUR AUDIO FILES HERE
            // Music files (lo-fi tracks)
            morningMusic: "./assets/audio/morning-lofi.mp3",
            sunsetMusic: "./assets/audio/sunset-lofi.mp3",
            nightMusic: "./assets/audio/night-lofi.mp3",
            rainMusic: "./assets/audio/rain-lofi.mp3",

            // Ambient sounds
            rainSound: "./assets/audio/rain-ambient.mp3",
            windSound: "./assets/audio/wind-ambient.mp3",
            thunderSound: "./assets/audio/thunder-ambient.mp3",
            engineSound: "./assets/audio/engine-hum.mp3",
          };

          // Create fallback assets when files don't exist
          await this.createFallbackAssets();
          this.updateLoadingProgress(100);
        }

        async createFallbackAssets() {
          // Load custom car model (OBJ)
          const objLoader = new THREE.OBJLoader();
          try {
            const carObj = await new Promise((resolve, reject) => {
              objLoader.load(
                "uploads_files_2787791_Mercedes+Benz+GLS+580.obj",
                resolve,
                undefined,
                reject
              );
            });
            // Optional: scale and position the car model
            carObj.scale.set(0.5, 0.5, 0.5);
            carObj.position.y = 1;
            carObj.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.material = new THREE.MeshLambertMaterial({
                  color: 0x4a90e2,
                });
              }
            });
            this.car = carObj;
            this.scene.add(this.car);
          } catch (e) {
            // Fallback to simple box car if loading fails
            const carGeometry = new THREE.BoxGeometry(4, 1.5, 8);
            const carMaterial = new THREE.MeshLambertMaterial({
              color: 0x4a90e2,
            });
            this.car = new THREE.Mesh(carGeometry, carMaterial);
            this.car.position.y = 1;
            this.car.castShadow = true;
            this.scene.add(this.car);
          }
          this.updateLoadingProgress(20);

          // Create simple terrain
          this.createTerrain();
          this.updateLoadingProgress(40);

          // Create lighting based on mood
          this.setupLighting();
          this.updateLoadingProgress(60);

          // Create simple audio (silent audio nodes for now)
          if (this.audioManager) {
            this.audioManager.setupSilentNodes();
          }
          this.updateLoadingProgress(80);
        }

        createTerrain() {
          // Create road segments
          for (let i = 0; i < this.visibleChunks; i++) {
            this.createRoadChunk(i);
          }

          // Create multiple ground chunks that move with the car
          this.groundChunks = [];
          for (let i = 0; i < this.visibleChunks + 2; i++) {
            const groundGeometry = new THREE.PlaneGeometry(200, this.chunkSize);
            const groundMaterial = new THREE.MeshLambertMaterial({
              color: 0x2d5016,
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = i * this.chunkSize - this.chunkSize * 2;
            ground.receiveShadow = true;
            this.scene.add(ground);
            this.groundChunks.push(ground);
          }

          // Add trees that regenerate
          this.trees = [];
          this.createTrees();
        }

        createRoadChunk(index) {
          const roadGeometry = new THREE.PlaneGeometry(8, this.chunkSize);
          const roadMaterial = new THREE.MeshLambertMaterial({
            color: 0x333333,
          });
          const road = new THREE.Mesh(roadGeometry, roadMaterial);

          road.rotation.x = -Math.PI / 2;
          road.position.z = index * this.chunkSize - this.chunkSize * 2;
          road.position.y = 0.01;
          road.receiveShadow = true;

          this.scene.add(road);
          this.terrainChunks.push(road);
        }

        createTrees() {
          // Create trees for each terrain chunk
          for (
            let chunkIndex = 0;
            chunkIndex < this.visibleChunks + 2;
            chunkIndex++
          ) {
            const chunkTrees = [];
            const treesPerChunk = 15;

            for (let i = 0; i < treesPerChunk; i++) {
              // Tree trunk
              const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 4);
              const trunkMaterial = new THREE.MeshLambertMaterial({
                color: 0x8b4513,
              });
              const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

              // Tree leaves
              const leavesGeometry = new THREE.SphereGeometry(2, 8, 6);
              const leavesMaterial = new THREE.MeshLambertMaterial({
                color: 0x228b22,
              });
              const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
              leaves.position.y = 3;

              const tree = new THREE.Group();
              tree.add(trunk);
              tree.add(leaves);

              // Position within chunk bounds
              tree.position.x = (Math.random() - 0.5) * 80;
              tree.position.z =
                chunkIndex * this.chunkSize +
                (Math.random() - 0.5) * this.chunkSize -
                this.chunkSize * 2;
              tree.position.y = 0;

              // Don't place trees on road
              if (Math.abs(tree.position.x) < 8) {
                i--; // Try again
                continue;
              }

              tree.castShadow = true;
              tree.userData = { chunkIndex: chunkIndex };
              this.scene.add(tree);
              chunkTrees.push(tree);
            }
            this.trees.push(...chunkTrees);
          }
        }

        setupLighting() {
          // Remove existing lights
          const existingLights = this.scene.children.filter(
            (child) => child.isLight
          );
          existingLights.forEach((light) => this.scene.remove(light));

          const moods = {
            morning: {
              skyColor: 0xfff4e6,
              fogColor: 0xfff4e6,
              lightColor: 0xffffff,
              lightIntensity: 0.8,
              ambientIntensity: 0.3,
            },
            sunset: {
              skyColor: 0xff7f50,
              fogColor: 0xff7f50,
              lightColor: 0xffa500,
              lightIntensity: 0.6,
              ambientIntensity: 0.4,
            },
            night: {
              skyColor: 0x1a1a2e,
              fogColor: 0x1a1a2e,
              lightColor: 0x4169e1,
              lightIntensity: 0.3,
              ambientIntensity: 0.2,
            },
            rain: {
              skyColor: 0x708090,
              fogColor: 0x708090,
              lightColor: 0x778899,
              lightIntensity: 0.4,
              ambientIntensity: 0.3,
            },
          };

          const mood = moods[this.currentMood];

          // Sky/fog
          this.scene.background = new THREE.Color(mood.skyColor);
          this.scene.fog = new THREE.Fog(mood.fogColor, 10, 100);

          // Directional light (sun/moon)
          const directionalLight = new THREE.DirectionalLight(
            mood.lightColor,
            mood.lightIntensity
          );
          directionalLight.position.set(10, 10, 5);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 1024;
          directionalLight.shadow.mapSize.height = 1024;
          this.scene.add(directionalLight);

          // Ambient light
          const ambientLight = new THREE.AmbientLight(
            mood.lightColor,
            mood.ambientIntensity
          );
          this.scene.add(ambientLight);
        }

        createScene() {
          // Position camera behind car
          this.updateCameraPosition();
        }

        updateCameraPosition() {
          if (!this.car) return;

          const carPosition = this.car.position.clone();
          const cameraDistance = this.isDriving ? 15 : 20;
          const cameraHeight = this.isDriving ? 8 : 12;

          // Smooth camera follow with less jitter
          const targetPosition = new THREE.Vector3(
            carPosition.x,
            carPosition.y + cameraHeight,
            carPosition.z - cameraDistance
          );

          // Smoother camera movement
          this.camera.position.lerp(targetPosition, 0.02);

          // Smooth look-at with slight offset for more natural feel
          const lookAtTarget = new THREE.Vector3(
            carPosition.x,
            carPosition.y + 2,
            carPosition.z + 10
          );

          this.camera.lookAt(lookAtTarget);
        }

        setupEventListeners() {
          // Keyboard input
          document.addEventListener("keydown", (e) => {
            this.keys[e.code] = true;

            if (e.code === "Space" || e.code === "KeyF") {
              e.preventDefault();
              this.isAutoMode = !this.isAutoMode;
            }

            if (e.code === "KeyM") {
              this.audioManager?.toggleMusic();
            }
          });

          document.addEventListener("keyup", (e) => {
            this.keys[e.code] = false;
          });

          // UI event listeners
          document.querySelectorAll(".mood-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              this.changeMood(btn.dataset.mood);
              document
                .querySelectorAll(".mood-btn")
                .forEach((b) => b.classList.remove("active"));
              btn.classList.add("active");
            });
          });

          document.querySelectorAll(".mode-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              this.changeMode(btn.dataset.mode);
              document
                .querySelectorAll(".mode-btn")
                .forEach((b) => b.classList.remove("active"));
              btn.classList.add("active");
            });
          });

          // Touch controls for mobile
          this.setupTouchControls();
        }

        setupTouchControls() {
          let touchStartX = 0;
          let touchStartY = 0;

          document.addEventListener("touchstart", (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          });

          document.addEventListener("touchmove", (e) => {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;

            // Simple touch steering
            if (Math.abs(deltaX) > 20) {
              this.keys["ArrowLeft"] = deltaX < 0;
              this.keys["ArrowRight"] = deltaX > 0;
            }

            if (Math.abs(deltaY) > 20) {
              this.keys["ArrowUp"] = deltaY < 0;
              this.keys["ArrowDown"] = deltaY > 0;
            }
          });

          document.addEventListener("touchend", () => {
            this.keys["ArrowLeft"] = false;
            this.keys["ArrowRight"] = false;
            this.keys["ArrowUp"] = false;
            this.keys["ArrowDown"] = false;
          });
        }

        changeMood(mood) {
          this.currentMood = mood;
          this.setupLighting();
          this.audioManager?.changeMood(mood);
        }

        changeMode(mode) {
          this.isDriving = mode === "driving";
          if (!this.isDriving) {
            // Stop the car when in standing mode
            this.car.position.set(0, 1, 0);
          }
        }

        updateCarMovement() {
          if (!this.car) return;

          const speed = 0.2; // Reduced speed for smoother movement
          const turnSpeed = 0.02;

          if (this.isDriving) {
            if (this.isAutoMode) {
              // Auto driving - smooth forward movement
              this.car.position.z += speed * 0.6;

              // Very subtle side-to-side movement for realism
              const time = Date.now() * 0.001;
              const sideMovement = Math.sin(time * 0.3) * 0.005;
              this.car.position.x += sideMovement;

              // Gentle rotation variation
              this.car.rotation.y = Math.sin(time * 0.2) * 0.02;
            } else {
              // Manual driving
              let moveZ = 0;
              let rotateY = 0;

              if (this.keys["ArrowUp"] || this.keys["KeyW"]) moveZ = speed;
              if (this.keys["ArrowDown"] || this.keys["KeyS"])
                moveZ = -speed * 0.5;
              if (this.keys["ArrowLeft"] || this.keys["KeyA"])
                rotateY = turnSpeed;
              if (this.keys["ArrowRight"] || this.keys["KeyD"])
                rotateY = -turnSpeed;

              this.car.rotation.y += rotateY;
              this.car.position.x += Math.sin(this.car.rotation.y) * moveZ;
              this.car.position.z += Math.cos(this.car.rotation.y) * moveZ;
            }

            // Update terrain chunks as car moves
            this.updateTerrain();
          }
        }

        updateTerrain() {
          // Simple terrain looping - move chunks as car progresses
          const carZ = this.car.position.z;

          this.terrainChunks.forEach((chunk, index) => {
            if (chunk.position.z < carZ - this.chunkSize * 3) {
              chunk.position.z += this.chunkSize * this.visibleChunks;
            }
          });
        }

        updateLoadingProgress(progress) {
          this.loadingProgress = progress;
          const progressBar = document.getElementById("loadingProgress");
          if (progressBar) {
            progressBar.style.width = progress + "%";
          }
        }

        hideLoadingScreen() {
          const loadingScreen = document.getElementById("loadingScreen");
          setTimeout(() => {
            loadingScreen.style.opacity = "0";
            setTimeout(() => {
              loadingScreen.style.display = "none";
            }, 1000);
          }, 500);
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          this.updateCarMovement();
          this.updateCameraPosition();

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Simple Audio Manager
      class AudioManager {
        constructor(audioContext) {
          this.audioContext = audioContext;
          this.masterGain = audioContext.createGain();
          this.masterGain.connect(audioContext.destination);

          this.musicGain = audioContext.createGain();
          this.ambientGain = audioContext.createGain();

          this.musicGain.connect(this.masterGain);
          this.ambientGain.connect(this.masterGain);

          this.currentMusic = null;
          this.ambientSounds = [];
          this.musicMuted = false;
        }

        setupSilentNodes() {
          // Create silent audio nodes as placeholders
          // Replace this with actual audio loading when you have audio files
          console.log(
            "Audio system ready - add your audio files to enable sound"
          );
        }

        changeMood(mood) {
          // This is where you'd switch between different audio tracks
          console.log("Changing mood to:", mood);
          // Example: this.playMusic(`./assets/audio/${mood}-lofi.mp3`);
        }

        toggleMusic() {
          this.musicMuted = !this.musicMuted;
          this.musicGain.gain.value = this.musicMuted ? 0 : 0.7;
          console.log("Music", this.musicMuted ? "muted" : "unmuted");
        }
      }

      // Start the game
      document.addEventListener("DOMContentLoaded", () => {
        new LoFiDriveGame();
      });
    </script>
  </body>
</html>
